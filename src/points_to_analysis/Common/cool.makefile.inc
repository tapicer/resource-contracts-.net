# UNDONE [rokyu 09/03/99]: Improve the description of the build model 
#   defined by this file and cool.sources.inc.
#
# In the sources file you can define the following macros to configure the
# build (as needed for the standard rules in makefile.def).
#   COOLC_MAKE_DLL
#   COOLC_MAKE_EXE
#   COOLC_INCLUDE
#   COOLC_FLAGS
#   COOLC_SOURCES
#   COOLC_RES
#   COOLC_MANAGED_RES
#   COOLC_RESOURCE_LOCALES
#   COOLC_RESOURCE_ASSEMBLYNAME
#
# 
# You must explicitly enable building the target. This file defines the
# following targets which you can use:
#   cooltarget_PE    Binary
#   cooltarget_TLB   Typelib generated by running the PE through tlbexp
#   cooltarget_H     Header file generated by running importing typelib into C++
#   cooltarget_RES   Build resources defined in COOLC_RESOURCE_TARGETS
#
# Building cooltarget_H automatically forces cooltarget_TLB to be built. 
# Building cooltarget_TLB automatically forces cooltarget_PE to be built. 
# The header file is deposited in INCDIR, the PE and TLB are deposited in 
# OUTDIR. The TLB needs to be in the same directory as the PE because 
# tlbexp needs this. I need to rationalize this better.
#
# The macros NTTARGETFILE0, NTTARGETFILE1, NTTARGETFILE2 and NTTARGETFILES 
# can be used to make the cool targets build during different passes of the 
# build. e.g. To build in PASS0,
#   NTTARGETFILE0=cooltarget_TLB
#
# In order to force a rebuild when the user types in build -o, we add a
# dependency to all the targets on a dummy file in the $(OBJDIR). 

# Include this file in makefile.inc. A corresponding file called
# sources.cool.inc should be included at the top of the sources file
# right after the inclusion of sources.inc.

!ifndef COOL_SOURCES_INC
!error Include vba\whidbeyscript\Common\cool.sources.inc in the file 'sources'.
!endif



# Calculate the import dependencies by stripping out the flags. e.g.
#       COOLC_INCLUDE=/r:System.XSP.dll /r:System.XSP.Pages.dll
# ==>   COOLC_INCLUDE_DEPEDENTS=System.XSP.dll System.XSP.Pages.dll
COOLC_INCLUDE=$(COOLC_INCLUDE:/addmodule=/r)
_TEMP_INCLUDE_0_=$(COOLC_INCLUDE:/r:=)
_TEMP_INCLUDE_1_=$(_TEMP_INCLUDE_0_:/R:=)
COOLC_INCLUDE_DEPENDENTS=$(_TEMP_INCLUDE_1_:/addmodule:=)


# Make sure the user hasn't defined COOLC_ASSEMBLY_VERSION. We always
# calculate this from the version resource.
!ifdef COOLC_ASSEMBLY_VERSION
!error No need to define COOLC_ASSEMBLY_VERSION. It is computed from vs\src\common\inc\version.h
!endif
!ifdef COOLC_ASSEMBLY_TITLE
!error Do not define COOLC_ASSEMBLY_TITLE. Use SCRIPT_ASSEMBLY_TITLE instead.
!endif
!ifdef COOLC_ASSEMBLY_DESCRIPTION
!error Do not define COOLC_ASSEMBLY_DESCRIPTION. Use SCRIPT_ASSEMBLY_DESCRIPTION instead.
!endif


#=========================================================================
COOLC_RESPONSEFILE=$(OBJDIR)\coolc_options.txt
COOLC_ASSEMBLYATTRIBUTEFILE=$(OBJDIR)\AssemblyAttributes.cs

!ifndef COOLC_DLLBASEFILE
COOLC_DLLBASEFILE=$(COFFBASE_TXT_FILE)
!endif
!ifndef COOLC_REVISION
COOLC_REVISION=0
!endif

#=========================================================================
# The OFFICIAL key only contains the public key. When we build
# shipping binaries, we only set the originator. We cannot sign it in the
# build because signing requires the corresponding private key which 
# is held by PRS (http://prslab).
#
# For test assemblies, we use our own INTERNALKEY that contains both the
# private and public keys. We sign the binaries in this case.
SECDIRECTORY=$(VSROOT)\src\common\security
OFFICIALKEY=$(SECDIRECTORY)\FinalPublicKey.snk
INTERNALKEY=$(SECDIRECTORY)\InterimKey.snk

!if "$(COOLC_DONOTSHIP)"=="1"
LM_FLAGS=$(LM_FLAGS) -t -k $(INTERNALKEY)
ALINK_FLAGS=$(ALINK_FLAGS) /keyf:$(INTERNALKEY)
SCRIPT_KEYFILE=$(INTERNALKEY)
SCRIPT_DELAYSIGN=false
!else
LM_FLAGS=$(LM_FLAGS) -t -o $(OFFICIALKEY)
ALINK_FLAGS=$(ALINK_FLAGS) /delaysign /keyf:$(INTERNALKEY)
SCRIPT_KEYFILE=$(OFFICIALKEY)
SCRIPT_DELAYSIGN=true
!endif

#=========================================================================
!ifdef COOLC_WARNLEVEL
COOLC_FLAGS=$(COOLC_FLAGS) /W:$(COOLC_WARNLEVEL)
!endif 
!ifdef COOLC_CULTURE
COOLC_FLAGS=$(COOLC_FLAGS) /a.culture:$(COOLC_CULTURE)
!endif

#=========================================================================
!ifdef COOLC_RES
COOLC_RES_TARGET=$(OBJDIR)\$(COOLC_RES)

# Rule to build resource files. The normal build does not build correctly
# if the dependency is in pass 0.
$(COOLC_RES_TARGET) : $(COOLC_RES:.res=.rc)
    $(RC_COMPILER) -r -fo $(@R).tmp $(CDEFINERC) $(FULL_INCL_PATH) $(COOLC_RES:.res=.rc)
    $(CVTRES) -nologo -machine:$(MACHINE_TYPE) -readonly -out:$@ $(@R).tmp
! IF "$(NTKEEPRESOURCETMPFILES)" == ""
    @-erase $(@R).tmp
! ENDIF
!endif

#=========================================================================
!ifdef COOLC_MANAGED_RES
COOLC_MANAGED_RES_TARGET=$(OBJDIR)\$(COOLC_MANAGED_RES)
COOLC_FLAGS=$(COOLC_FLAGS) /resource:$(COOLC_MANAGED_RES_TARGET),$(COOLC_MANAGED_RES)

$(COOLC_MANAGED_RES_TARGET) : $(COOLC_MANAGED_RES:.resources=.txt)
    $(RESGEN_CMD) $(RESGEN_FLAGS) $(COOLC_MANAGED_RES:.resources=.txt) $(COOLC_MANAGED_RES_TARGET) 
!endif 

#=========================================================================
!ifdef COOLC_MAKE_DLL

!ifdef COOLC_MAKE_EXE
!error Only one of COOLC_MAKE_DLL and COOLC_MAKE_EXE cannot be defined.
!endif

# Calculate the path minus any 
COOLC_TARGET_BASENAME=$(COOLC_MAKE_DLL:.dll=)
COOLC_TARGET_BASENAME=$(COOLC_TARGET_BASENAME:.DLL=)
COOLC_TARGET_BASENAME=$(COOLC_TARGET_BASENAME:.Dll=)

# Verify that the DLL target has a .DLL suffix
!if "$(COOLC_TARGET_BASENAME)"=="$(COOLC_MAKE_DLL)"
!error COOLC_MAKE_DLL should have a ".dll" extension.
!endif 

!endif
#=========================================================================
!ifdef COOLC_MAKE_EXE

# Calculate the path minus any 
COOLC_TARGET_BASENAME=$(COOLC_MAKE_EXE:.exe=)
COOLC_TARGET_BASENAME=$(COOLC_TARGET_BASENAME:.EXE=)
COOLC_TARGET_BASENAME=$(COOLC_TARGET_BASENAME:.Exe=)

# Verify that the EXE target has a .EXE
!if "$(COOLC_TARGET_BASENAME)"=="$(COOLC_MAKE_EXE)"
!error COOLC_MAKE_EXE should have a ".exe" extension.
!endif 

!endif
#=========================================================================
# Dummy file used to trigger rebuild when -c flag is specified to build
DUMMYFILE=$(OBJDIR)\dummy.txt

$(DUMMYFILE):
    echo This is a dummy file > $(DUMMYFILE)

#=========================================================================
# Output location for file.
!ifdef COOLC_OUTPUTDIR
$(COOLC_OUTPUTDIR):
    if not exist $(COOLC_OUTPUTDIR) md $(COOLC_OUTPUTDIR)
!endif

COOLC_TARGET_PE_BASENAME=$(COOLC_OUTPUTDIR)\$(COOLC_TARGET_BASENAME)

#=========================================================================
$(COOLC_RESPONSEFILE): $(COOLC_DLLBASEFILE)
!ifdef COOLC_DLLBASE
    cscript //nologo $(VSROOT)\public\tools\cscdllbase.js $(COOLC_DLLBASEFILE) $(COOLC_DLLBASE) >$(COOLC_RESPONSEFILE)
!else
    echo.>$(COOLC_RESPONSEFILE)
!endif


#=========================================================================
$(COOLC_ASSEMBLYATTRIBUTEFILE): $(VSROOT)\src\common\inc\version.h
!ifdef SCRIPT_ASSEMBLY_SUPPRESS_VERSION
    cscript //nologo $(VSROOT)\public\tools\cscassemblyattributes.js $(SCRIPT_ASSEMBLY_TITLE) $(SCRIPT_ASSEMBLY_DESCRIPTION) $(SCRIPT_KEYFILE) $(SCRIPT_DELAYSIGN) >$(COOLC_ASSEMBLYATTRIBUTEFILE)
!else
    cscript //nologo $(VSROOT)\public\tools\cscassemblyattributes.js $(SCRIPT_ASSEMBLY_TITLE) $(SCRIPT_ASSEMBLY_DESCRIPTION) $(SCRIPT_KEYFILE) $(SCRIPT_DELAYSIGN) $(VSROOT)\src\common\inc\version.h $(COOLC_REVISION) >$(COOLC_ASSEMBLYATTRIBUTEFILE)
!endif

#=========================================================================
!ifdef COOLC_TARGET_BASENAME
#=========================================================================

COOLC_TARGET_PDB=$(COOLC_TARGET_PE_BASENAME).pdb

cooltarget_PE: $(COOLC_TARGET_PE)

$(COOLC_TARGET_PE): $(DUMMYFILE) $(COOLC_OUTPUTDIR) $(COOLC_RESPONSEFILE) $(COOLC_ASSEMBLYATTRIBUTEFILE) $(COOLC_INCLUDE_DEPENDENTS) $(COOLC_RES_TARGET) $(COOLC_MANAGED_RES_TARGET) $(COOLC_SOURCES)
    if exist $(COOLC_TARGET_PDB) del $(COOLC_TARGET_PDB)
    echo cl $(COOLC_TARGET_PE)
    type $(COOLC_RESPONSEFILE) | findstr [^\s]
    $(COOLC_CMD) $(COOLC_FLAGS) $(COOLC_WARNOPTION) $(COOLC_LOCALEOPTION) @$(COOLC_RESPONSEFILE) /nostdlib $(COOLC_SOURCES) $(COOLC_ASSEMBLYATTRIBUTEFILE)
!ifdef COOLC_MAKE_DLL
    $(REGASM_CMD) $(REGASM_FLAGS) /regfile:$(OBJDIR)\$(COOLC_MAKE_DLL:.dll=.reg) $(COOLC_TARGET_PE)
    cscript //nologo //E:jscript $(VSROOT)\src\vsa\whidbeyscript\Common\mungereg.js $(OBJDIR)\$(COOLC_MAKE_DLL:.dll=.reg) >$(COOLC_TARGET_PE:.dll=.reg)
    $(URTSDKROOT)\bin\sn -e $(COOLC_TARGET_PE) $(O)\pubkey.snk
    $(URTSDKROOT)\bin\sn -T $(COOLC_TARGET_PE) > $(O)\pubkey.tmp
    perl $(VSROOT)\public\tools\genpubpol.pl $(COOLC_OUTPUTDIR) $(COOLC_MAKE_DLL:.dll=) $(O)\pubkey.tmp $(O)\al.rsp
    $(DEVTOOLS)\$(PROCESSOR_ARCHITECTURE)\$(VC)\bin\al.exe /delaysign+ /keyf:$(O)\pubkey.snk @$(O)\al.rsp
!if "$(BT_BISLABMACHINE)" == ""
    $(GACUTIL_CMD) $(GACUTIL_FLAGS) -i $(COOLC_TARGET_PE)
    $(REGASM_CMD) $(REGASM_FLAGS) $(COOLC_TARGET_PE)
!endif
!endif

#=========================================================================
COOLC_TARGET_TLB=$(COOLC_TARGET_PE_BASENAME).tlb

cooltarget_TLB: $(COOLC_TARGET_TLB)

!ifdef COOLC_TLB_RES

COOLC_TLB_RES_TARGET=$(OBJDIR)\$(COOLC_TLB_RES)

$(COOLC_TARGET_TLB): $(DUMMYFILE) $(COOLC_TLB_RES_TARGET)
    $(LINKER) -dll -nodefaultlib -debug:none -noentry -heap:0,0 -stack:0,0 -out:$(OBJDIR)\$(COOLC_MAKE_DLL:.dll=.tlb.dll)  $(COOLC_TLB_RES_TARGET)
    copy $(OBJDIR)\$(COOLC_MAKE_DLL:.dll=.tlb.dll) $(COOLC_TARGET_TLB)

# Rule to build resource files. The normal build does not build correctly
# if the dependency is in pass 0.
$(COOLC_TLB_RES_TARGET) : $(COOLC_TLB_RES:.res=.rc) $(OBJDIR)\$(COOLC_MAKE_DLL:.dll=.tlb)
    $(RC_COMPILER) -r -fo $(@R).tmp $(CDEFINERC)  /i$(OBJDIR) $(FULL_INCL_PATH) $(COOLC_TLB_RES:.res=.rc)
    $(CVTRES) -nologo -machine:$(MACHINE_TYPE) -readonly -out:$@ $(@R).tmp
! IF "$(NTKEEPRESOURCETMPFILES)" == ""
    @-erase $(@R).tmp
! ENDIF

$(OBJDIR)\$(COOLC_MAKE_DLL:.dll=.tlb): $(DUMMYFILE) $(COOLC_TARGET_PE)
    $(TLBEXP_CMD) $(TLBEXP_FLAGS) $(COOLC_TARGET_PE) /out:$(OBJDIR)\$(COOLC_MAKE_DLL:.dll=.tlb)
    
!else

$(COOLC_TARGET_TLB): $(DUMMYFILE) $(COOLC_TARGET_PE)
    $(TLBEXP_CMD) $(TLBEXP_FLAGS) $(COOLC_TARGET_PE) /out:$(COOLC_TARGET_TLB)

!endif



#=========================================================================
COOLC_TARGET_H=$(INCDIR)\$(COOLC_TARGET_BASENAME).h
TLHFILE=$(OBJDIR)\$(COOLC_TARGET_BASENAME).tlh

cooltarget_H: $(COOLC_TARGET_H)

$(COOLC_TARGET_H): $(DUMMYFILE) $(TLHFILE)

$(TLHFILE): $(COOLC_TARGET_TLB)
    echo #pragma warning(push) >$(TLHFILE).cpp
    echo #pragma warning(disable:4336) // Import cross referenced typelib >>$(TLHFILE).cpp
    echo #pragma warning(disable:4278) // Identifier in typelib clashes with MACRO >>$(TLHFILE).cpp
    echo #pragma warning(disable:4279) // Identifier in typelib clashes with keyword >>$(TLHFILE).cpp
    echo #import "$(COOLC_TARGET_TLB)" no_namespace no_implementation raw_interfaces_only >>$(TLHFILE).cpp
    echo #pragma warning(pop) >>$(TLHFILE).cpp
    PATH=$(COOLC_OUTPUTDIR);$(PATH)
    $(C_COMPILER) /Fo$(TLHFILE).obj $(TLHFILE).cpp

#=========================================================================
!endif
#=========================================================================


#=========================================================================
!ifdef COOLC_RESOURCE_LOCALES

cooltarget_RES: $(OBJDIR)\createres.wsf

$(OBJDIR)\createres.wsf: $(VSROOT)\src\common\inc\version.h
    rem <<$(OBJDIR)\createres.wsf
<job>

<script language="jscript">
function GetFileVersion(filename){
    var fso = new ActiveXObject("Scripting.FileSystemObject")
    var text = fso.OpenTextFile(filename).ReadAll()
    
    var rmj = /#define rmj[\s]*([\d]*)/i.exec(text)[1];
    var rmm = /#define rmm[\s]*([\d]*)/i.exec(text)[1];
    var rev = "0";
    var rup = /#define rup[\s]*([\d]*)/i.exec(text)[1];
    
    return rmj + "." + rmm + "." + rev + "." + rup;
}
</script>

<script language="vbscript">
Option Explicit
Dim WshShell, fso
Set WshShell = CreateObject("WScript.Shell")
Set fso = CreateObject("Scripting.FileSystemObject")

Sub Run(filename, command)
    Dim errorlevel, msg
    
    On Error Resume Next
    
    msg = "Command returned an error code - " & command
    errorlevel = WshShell.Run(command, 0, true)
    If Err.Number <> 0 And 0 = errorlevel Then
        errorlevel = Err.Number
        If Err.Description <> "" Then
            msg = Err.Description
        End If
    End If
    If errorlevel <> 0 Then
        WScript.Echo filename & "(1) : error " & errorlevel & ": " & msg
        WScript.Quit errorlevel
    End If
End Sub


Sub GenerateResourceDll(locale)
    Dim name, simple, localized, source, file, path
    
    name = "$(COOLC_RESOURCE_ASSEMBLYNAME)"         'Microsoft.JScript
    simple = name & ".resources"                    'Microsoft.JScript.resources
    localized = name & "." & locale & ".resources"  'Microsoft.JScript.de.resources
    If locale = "en" Then
        source = name & ".txt"                      'Microsoft.JScript.txt for english
    Else
        source = name & "." & locale & ".txt"       'Microsoft.JScript.de.txt
    End If
    file = locale & "\" & simple & ".mcl"           'de\Microsoft.JScript.resources.mcl
    
    path = "$(COOLC_OUTPUTDIR)\" & locale           'e:\vs\vsbuilt\debug\bin\i386\de
    If Not fso.FolderExists(path) Then
        fso.CreateFolder path
    End If 
    
    WScript.Echo "cl $(TARGET_DIRECTORY) " & file
    Run source, "$(RESGEN_CMD) $(RESGEN_FLAGS) " & source & " $(OBJDIR)\" & localized
    Run source, "$(ALINK_CMD) $(ALINK_FLAGS) /out:$(OBJDIR)\" & simple & ".mcl /c:" & locale & _
            " /v:" & GetFileVersion("$(VSROOT)\src\common\inc\version.h") & _
            " /embed:" & "$(OBJDIR)\" & localized & "," & localized & ",Y" 
    Run source, "cp /y ""$(OBJDIR)\" & simple & ".mcl"" ""$(COOLC_OUTPUTDIR)\" & file & """"
End Sub

Dim i
For i = 0 To WScript.Arguments.Count - 1
    GenerateResourceDll WScript.Arguments(i)
Next
</script>
</job>
<<KEEP 
    cscript /nologo $(OBJDIR)\createres.wsf $(COOLC_RESOURCE_LOCALES)

    
!endif

#=========================================================================
COOLC_TARGETS=$(COOLC_TARGET_PE) $(COOLC_TARGET_PDB) $(COOLC_TARGET_TLB) $(COOLC_TARGET_H) $(COOLC_RESPONSEFILE) $(COOLC_VERSION_OPTIONFILE)

clean:
    for %i in ($(COOLC_TARGETS) $(TARGET)) do if exist %i del %i
    for %i in ($(COOLC_RESOURCE_LOCALES)) do if exist $(COOLC_OUTPUTDIR)\%i\$(COOLC_RESOURCE_ASSEMBLYNAME).resources.mcl del $(COOLC_OUTPUTDIR)\%i\$(COOLC_RESOURCE_ASSEMBLYNAME).resources.mcl
    

